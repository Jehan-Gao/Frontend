## 从输入URL到页面展示，中间发生了什么？

从用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。下面将逐一分析。

### 1.用户输入
当用户在浏览器地址栏输入一个查询关键字的时候，浏览器地址栏会判断输入的关键字是搜索的内容还是
请求的URL。
  - 如果是搜索内容，地址栏就会使用浏览器默认的搜索引擎，来生成新的带搜索关键字的请求URL。
  - 如果判断输入内容符合URL规则，比如输入的是 `www.baidu.com`，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 `https://www.baidu.com`。

当用户在地址栏输入内容并按下回车键后，这意味着当前页面即将要被替换成我们请求的页面。
但是在这个流程之前，浏览器还会给当前页面执行一次 `beforeunload`事件的机会，`beforeunload`事件允许当前页面在离开前执行一些收尾工作，如数据清理，还可以询问用户是否要离开当前页面，如当前页面有未完成提交的表单信息，所以用户可以通过 `beforeunload`事件来取消导航，让浏览器不再执行后面的操作。

如果页面没有监听`beforeunload`事件或者用户同意执行后续的操作后，浏览器的Tab页会出现转圈加载的图标。

### 2.浏览器端URL请求过程
  浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

  请求流程如下：
  - 网络进程查找本地缓存是否缓存了该资源，如果有缓存，直接返回资源给浏览器进程。
  - 如果本地没有缓存，网络进程就构建请求，准备发起请求。
  - 请求DNS，得到对应的IP地址。在和服务器建立TCP连接的时候，在`传输层`需要添加TCP头（源主机ip、目标主机端口、数据包序列号(用来重排数据包)），在`网络层`添加IP头。而端口的获取，可通过用户输入的URL中可以获取到，默认情况下，没有写端口的话，HTTP协议的默认端口是80，HTTPS的默认端口是443。
  浏览器中还有**DNS数据缓存服务**，如果域名已经解析过了，那么浏览器就会缓存解析的结果，下次查询的时候直接使用解析到的ip地址，这样也可以减少一次网络请求。
  - 等待TCP队列。上一步已经把ip地址和端口已经准备好了，但不会立马发起请求。Chrome有个机制，同一个域名下最多只能建立6个TCP连接。如果同一个域名在有10个请求要发出，那么另外四个请求就会进入队列中等待，直至进行中的请求完成，这四个请求才会执行。
  如果同一域名下的请求少于6个，则会立马进入下一步，建立TCP连接。
  （以上描述的是HTTP1的机制，HTTP2提供了多路复用的机制，到时候再补充）
  - 建立TCP连接（三次握手：在建立一个TCP连接时，客户端和服务端总共要发送三次数据包来确认连接的建立）。
  - 发送HTTP请求。
      >一次完整的TCP的过程包括三个阶段：建立连接阶段(三次握手)-> 数据传输阶段 -> 断开连接阶段（四次挥手）。而HTTP请求阶段就是在TCP的数据传输阶段完成的。
  浏览器端会构建请求行、请求头、请求体（GET请求没有）等信息、并把和该域名相关的Cookie等数据附加到请求头中（如果存在Cookie的话），然后向服务器发送构建的请求信息。

### 3.服务器端处理URL请求过程
  服务器在接收到请求之后，会根据浏览器的请求信息来准备相应的内容。
  - 返回请求。一旦服务器处理结束，就会返回数据给浏览器。
    ```
      通过以下命令可查看浏览器返回的信息
      curl -i https://www.baidu.com/
    ```
    服务器会返回响应行（协议和状态码）、响应头、响应体。响应头包含了服务器的一些自身信息，比如服务器返回数据的时间、返回的数据类型、以及服务器要在客户端保存的Cookie等信息。
  - 断开连接。通常情况下，服务器向浏览器返回了数据，它就要关闭TCP连接。如果浏览器或者服务器在请求头或者响应头中加入了：
    ``` 
    Connection:Keep-Alive 
    ```
    那么TCP连接在发送后仍然保持打开的状态，这样浏览器就可以通过同一个TCP连接继续发送请求。这样做的好处是：省去了创建TCP连接的时间，加快了资源请求速度。
    比如一个web页面内嵌的图片都来自同一个站点，如果初始化了一个持久连接，浏览器就能复用该连接，以请求其他资源，不需要再建立新的TCP连接。

### 4.浏览器处理服务器返回的数据
  当浏览器（具体的是网络进程）接收到服务器返回的数据后，就要开始解析响应头（这里将响应行和响应头统称为响应头）的内容了。
  - 重定向。在接收到服务器返回的响应头之后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头里获取`Location`字段对应的重定向URL，然后再重新发起请求，重复上面所有的操作。在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。
  - 响应数据类型处理。在处理完跳转信息之后，网络进程继续解析。网络进程会根据响应头中的`Content-Type`字段的值来判断服务器到底返回的是什么数据类型，然后浏览器会根据`Content-Type`的值来决定如何显示响应体的内容。
  如果`Content-Type`的值是`text/html`，这是告诉浏览器，服务器返回的是HTML格式。
  这种情况，浏览器会继续进行后面的导航流程，接下来就准备进入**渲染流程**了。
  如果`Content-Type`的值是`application/octet-stream`，这是告诉浏览器，服务器返回的是**字节流**类型的文件，通常会交给浏览器的**下载管理器**去执行。
  - 准备渲染进程。默认情况下Chrom会为每个页面分配一个渲染进程，但是有些情况是比较特殊的。当打开的页面都是同一站点（same-site）的话，那么这些页面都会运行在同一个渲染进程中。同一站点定义为：根域名加上协议，还包含了根域名下的所有子域名和不同的端口。下面这三个站点都属于同一站点。
  ```
    https://time.geekbang.org
    https://www.geekbang.org
    https://www.geekbang.org:8080
  ```
  Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance（翻译为每站一个进程）。

  渲染进程准备好之后，还不能立马进入文档解析状态，因为此时的文档数据还在网络进程中，还没有提交给渲染进程。
  - 提交文档。即浏览器将网络进程接收到的HTML文档提交给渲染进程，具体流程如下：
    - 当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息
    - 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”
    - 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
    - 浏览器进程在收到”确认提交“的消息后，会更新浏览器界面状态，包括了web安全状态、地址栏的URL、前后后退的历史状态、并更新web界面

    这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

    到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

### 5.浏览器渲染阶段

  待补充....