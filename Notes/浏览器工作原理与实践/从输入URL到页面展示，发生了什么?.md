## 从输入URL到页面展示，中间发生了什么？

从用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。下面将逐一分析。

### 1.用户输入
当用户在浏览器地址栏输入一个查询关键字的时候，浏览器地址栏会判断输入的关键字是搜索的内容还是
请求的URL。
  - 如果是搜索内容，地址栏就会使用浏览器默认的搜索引擎，来生成新的带搜索关键字的请求URL。
  - 如果判断输入内容符合URL规则，比如输入的是 `www.baidu.com`，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 `https://www.baidu.com`。

当用户在地址栏输入内容并按下回车键后，这意味着当前页面即将要被替换成我们请求的页面。
但是在这个流程之前，浏览器还会给当前页面执行一次 `beforeunload`事件的机会，`beforeunload`事件允许当前页面在离开前执行一些收尾工作，如数据清理，还可以询问用户是否要离开当前页面，如当前页面有未完成提交的表单信息，所以用户可以通过 `beforeunload`事件来取消导航，让浏览器不再执行后面的操作。

如果页面没有监听`beforeunload`事件或者用户同意执行后续的操作后，浏览器的Tab页会出现转圈加载的图标。

### 2.浏览器端URL请求过程
  浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

  请求流程如下：
  - 网络进程查找本地缓存是否缓存了该资源，如果有缓存，直接返回资源给浏览器进程。
  - 如果本地没有缓存，网络进程就构建请求，准备发起请求。
  - 请求DNS，得到对应的IP地址。在和服务器建立TCP连接的时候，在`传输层`需要添加TCP头（源主机ip、目标主机端口、数据包序列号(用来重排数据包)），在`网络层`添加IP头。而端口的获取，可通过用户输入的URL中可以获取到，默认情况下，没有写端口的话，HTTP协议的默认端口是80，HTTPS的默认端口是443。
  浏览器中还有**DNS数据缓存服务**，如果域名已经解析过了，那么浏览器就会缓存解析的结果，下次查询的时候直接使用解析到的ip地址，这样也可以减少一次网络请求。
  - 等待TCP队列。上一步已经把ip地址和端口已经准备好了，但不会立马发起请求。Chrome有个机制，同一个域名下最多只能建立6个TCP连接。如果同一个域名在有10个请求要发出，那么另外四个请求就会进入队列中等待，直至进行中的请求完成，这四个请求才会执行。
  如果同一域名下的请求少于6个，则会立马进入下一步，建立TCP连接。
  （以上描述的是HTTP1的机制，HTTP2提供了多路复用的机制，到时候再补充）
  - 建立TCP连接（三次握手：在建立一个TCP连接时，客户端和服务端总共要发送三次数据包来确认连接的建立）。
  - 发送HTTP请求。
      >一次完整的TCP的过程包括三个阶段：建立连接阶段(三次握手)-> 数据传输阶段 -> 断开连接阶段（四次挥手）。而HTTP请求阶段就是在TCP的数据传输阶段完成的。
  浏览器端会构建请求行、请求头、请求体（GET请求没有）等信息、并把和该域名相关的Cookie等数据附加到请求头中（如果存在Cookie的话），然后向服务器发送构建的请求信息。

### 3.服务器端处理URL请求过程
  服务器在接收到请求之后，会根据浏览器的请求信息来准备相应的内容。
  - 返回请求。一旦服务器处理结束，就会返回数据给浏览器。
    ```
      通过以下命令可查看浏览器返回的信息
      curl -i https://www.baidu.com/
    ```
    服务器会返回响应行（协议和状态码）、响应头、响应体。响应头包含了服务器的一些自身信息，比如服务器返回数据的时间、返回的数据类型、以及服务器要在客户端保存的Cookie等信息。
  - 断开连接。通常情况下，服务器向浏览器返回了数据，它就要关闭TCP连接。如果浏览器或者服务器在请求头或者响应头中加入了：
    ``` 
    Connection:Keep-Alive 
    ```
    那么TCP连接在发送后仍然保持打开的状态，这样浏览器就可以通过同一个TCP连接继续发送请求。这样做的好处是：省去了创建TCP连接的时间，加快了资源请求速度。
    比如一个web页面内嵌的图片都来自同一个站点，如果初始化了一个持久连接，浏览器就能复用该连接，以请求其他资源，不需要再建立新的TCP连接。

### 4.浏览器处理服务器返回的数据
  当浏览器（具体的是网络进程）接收到服务器返回的数据后，就要开始解析响应头（这里将响应行和响应头统称为响应头）的内容了。
  - 重定向。在接收到服务器返回的响应头之后，网络进程开始解析响应头，如果发现返回的状态码是301或者302，那么说明服务器需要浏览器重定向到其他URL。这时网络进程会从响应头里获取`Location`字段对应的重定向URL，然后再重新发起请求，重复上面所有的操作。在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。
  - 响应数据类型处理。在处理完跳转信息之后，网络进程继续解析。网络进程会根据响应头中的`Content-Type`字段的值来判断服务器到底返回的是什么数据类型，然后浏览器会根据`Content-Type`的值来决定如何显示响应体的内容。
  如果`Content-Type`的值是`text/html`，这是告诉浏览器，服务器返回的是HTML格式。
  这种情况，浏览器会继续进行后面的导航流程，接下来就准备进入**渲染流程**了。
  如果`Content-Type`的值是`application/octet-stream`，这是告诉浏览器，服务器返回的是**字节流**类型的文件，通常会交给浏览器的**下载管理器**去执行。
  - 准备渲染进程。默认情况下Chrom会为每个页面分配一个渲染进程，但是有些情况是比较特殊的。当打开的页面都是同一站点（same-site）的话，那么这些页面都会运行在同一个渲染进程中。同一站点定义为：根域名加上协议，还包含了根域名下的所有子域名和不同的端口。下面这三个站点都属于同一站点。
  ```
    https://time.geekbang.org
    https://www.geekbang.org
    https://www.geekbang.org:8080
  ```
  Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫 process-per-site-instance（翻译为每站一个进程）。

  渲染进程准备好之后，还不能立马进入文档解析状态，因为此时的文档数据还在网络进程中，还没有提交给渲染进程。
  - 提交文档。即浏览器将网络进程接收到的HTML文档提交给渲染进程，具体流程如下：
    - 当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息
    - 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”
    - 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
    - 浏览器进程在收到”确认提交“的消息后，会更新浏览器界面状态，包括了web安全状态、地址栏的URL、前后后退的历史状态、并更新web界面

    这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

    到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。

### 5.浏览器渲染流程(重中之重)
  下面将详细的分析浏览器的渲染流程。

  **构建DOM树**
  
  构建DOM树。浏览器不能直接使用和理解HTML,所以需要将HTML转换为浏览器能够理解的结构-DOM树。
  DOM树是保存在内存中的树状结构，可以通过JS来查询或者修改其内容。
  构建完DOM树，但是DOM节点中每个元素的样式我们还不知道，所以接下来就需要样式计算的环节了。

  **样式计算**

  1.把CSS转换为浏览器能理解的结构。
  当渲染引擎接收到CSS文本的时候，会将CSS转换为浏览器可以理解的结构-styleSheets(样式表)。

  2.转换样式表中的属性值，使其标准化。
  比如CSS样式中有`rem em blue bold`这些值或者单位时，这些值不容易被渲染引擎所理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

  3.计算出DOM树中每个节点的具体样式。
  - 首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式。
  - 第二个规则是样式层叠。层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。
  


  **布局阶段**

  1.创建布局树。
  DOM树中有可能有很多不可见的元素，比如head标签，还有使用了`display: none;`的元素。所以在显示前，渲染引擎还需要额外的构建一棵只包含可见元素的**布局树**。

  （在源码中没有CSSOM这个词，CSSROM对应的应该是styleSheets， 网上很多提到的渲染树也是很多年前的代码了，早就已经重构，现在叫布局树，和渲染树不太一样）

  2.布局计算。
  布局计算就是布局树中节点坐标位置（过程非常复杂）。在执行布局操作的时候，会把布局运算的结果重新写回到布局树中，
  这是布局阶段不合理的地方，因为在布局阶段并没有清晰的将输入内容和输出内容区别出来
 （针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单）。


  **分层**

  在上一步骤渲染进程生成了布局树后，并不会立马进行绘制。在页面中有很多复杂的效果，比如3D效果、页面滚动、或者使用z-index做z轴排序等，为了更方便的实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵图层树（LayerTree）。** 在chrome中通过Layers标签查看具体的图层。

  通常情况下，**并不是每个布局树的节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**

  通常满足以下两点中的任意一点的元素就可以被单独提升为一个图层：

  1.拥有层叠上下文属性的元素会被单独提升为一层。
  层叠上下文属性具体可以参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)。
  
  2.需要剪裁的地方也会创建图层。
  当文本内容溢出容器的时候，设置 `overflow: auto`。

  

  **图层绘制**

  渲染引擎的图层绘制与我们生活中绘制图画的步骤类似，会把一个图层的绘制分成很多个小的**绘制指令**（步骤），然后再把这些绘制指令组成一张**带绘制列表**，如下图：

  ![图层绘制](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6.png)
  （图片来自《浏览器工作原理与实践》）

  所以，在图层绘制阶段，输出的就是这些带绘制列表。


  **栅格(raster)操作**

  绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的**合成线程**来完成的。渲染主线程和合成线程之间的关系如下图：
  ![合成线程](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%90%88%E6%88%90%E7%BA%BF%E7%A8%8B.png)
  （图片来自《浏览器工作原理与实践》）
  当绘制列表准备好之后，主线程会把绘制列表提交给合成线程去处理。

  通常一个页面很大，用户只能看到其中一部分，我们用户可以把看到的这部分叫做视口。
  
  有些情况下，有的图层可能很大，比如有的页面需要滚动很久才能滚动到底部，但是通过视口，用户只能看到页面很小的一部分，所以在这种情况下，要绘制出所有图层内容的话，开销太大，也没有必要这样去做。

  基于这个原因，**合成线程会将图层划分为图块（tile）**,这些图块的大小通常是256x256或者512x512, 如下图显示：
  ![tile](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/tile.png)
  （图片来自《浏览器工作原理与实践》）

  然后**合成线程会按照视口附近的图块优先来生成位图，实际上生成位图的操作是又栅格化来执行的。栅格化就是将图块转换为位图的过程。** 而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：
  ![栅格化线程池](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%A0%85%E6%A0%BC%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0.png)
  （图片来自《浏览器工作原理与实践》）

  通常，栅格化过程都会使用GPU（图形处理器）来加速生成，使用GPU生成位图的过程叫快速栅格化或者GPU栅格化，**生成的位图保存在GPU内存中。**

  GPU又是一个单独的进程，如果栅格化操作使用了GPU,那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作，如下图：
  ![GPU通信](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/GPU%E9%80%9A%E4%BF%A1.png)
  （图片来自《浏览器工作原理与实践》）

  从图中看出，渲染进程把生成图块的指令发送给GPU，然后在GPU中执生成图块的位图，并保存在GPU的内存中。

  **合成显示**

  一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令-“DrawQuad”，然后将该命令提交给浏览器进程。

  浏览器进程中有个叫**viz**的组件，用来接收合成线程发送过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示到屏幕上。
  ![渲染完整流程](https://github.com/Jehan-Gao/images/raw/master/Images/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.png)
  （图片来自《浏览器工作原理与实践》）


  到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。